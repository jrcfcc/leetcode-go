package nums


/*
给定一个未排序的整数数组，找出其中没有出现的最小的正整数。

in-place 思想,原地替换
数组中的最小正整数
数组的长度为n,这个最小正整数肯定在[1-n+1]范围内
最极端的情况下，这个数组是从1开始连续递增的数组,那么未出现的最小正整数就是n+1
以[3,5,-1,1]为例，整个过程分两步
第一步：将数据放到他本来应该在的位置，即nums[i]=i+1,
1、对于 nums[0] = 3，需要将其放到第三个位置，即nums[2]的位置，因此调换nums[0]和nums[2]，数组变为[-1,5,3,1]。
然后nums[0] = -1,我们最后需要找的是缺失的第一个正数，因此-1这种可以直接舍弃，本轮循环结束，进入下一轮。
2、对于nums[1] = 5，因为数组的长度为4，因此，缺失的第一个正整数肯定小于5，因此5这种可以直接舍弃，本轮循环结束，进入下一轮。
3、对于nums[2] = 3,这个位置不需要进行调换，因为3现在正好在第三个位置，不需要调换。
4、对于nums[3] = 1,需要将其放到第一个位置，即nums[0]的位置，因此调换nums[0]和nums[3]，数组变为[1,5,3,-1]。
第二步：遍历数组，如果哪个位置nums[i]!=i+1,则他就是缺失的数。很明显[1,5,3,-1]缺失的第一个正整数为2

 */

func firstMissingPositive(nums []int) int {
	var l = len(nums)
	if l == 0 {
		return 1
	}
	for i:=0;i<l;i++{
		if i+1 == nums[i] {
			continue
		}
		//循环交换值,直到nums[i]处于它应该在的位置,负数则跳出循环,开始交换nums[i+1]
		Loop:
		for {
			v := nums[i]
			/*
			v > l ,说明这个数组中的未出现的最小值肯定比n+1小，
			也就是最终整理好的数组在i<n之前肯定会有nums[i]!=i+1的

			v <= 0 非正整数,不用调换,

			v == i+1 ,到达了正确的位置,不用处理

			v == nums[v],说明要交换的两个元素是相等的,也不用调换
			*/
			if v > l || v <= 0 || v == i + 1 ||  v == nums[v-1] {
				break Loop
			}
			nums[i],nums[v-1] = nums[v-1],nums[i]
		}
	}
	for i,v := range nums {
		if i+1 != v {
			return i+1
		}
	}
	return l + 1
}
